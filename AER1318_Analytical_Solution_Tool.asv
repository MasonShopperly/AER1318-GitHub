function AER1318_Analytical_Solution_Tool()
    % Create a figure for the GUI
    fig = figure('Name', 'AER1318 Analytical Solution Tool', ...
                 'NumberTitle', 'off', ...
                 'Position', [50, 550, 350, 200]); % Adjust the position to accommodate new button

    % Button for Exercise 3.1
    uicontrol('Style', 'pushbutton', 'String', 'Exercise 3.1', ...
              'Position', [50, 150, 250, 30], ...
              'Callback', @runExercise31);

    % Button for Exercise 3.2
    uicontrol('Style', 'pushbutton', 'String', 'Exercise 3.2', ...
              'Position', [50,110, 250, 30], ...
              'Callback', @runExercise32);

    % Button for Exercise 3.3
    uicontrol('Style', 'pushbutton', 'String', 'Exercise 3.3', ...
              'Position', [50, 70, 250, 30], ...
              'Callback', @runExercise33);

    % Button to Reset Plots
    uicontrol('Style', 'pushbutton', 'String', 'Reset Plots', ...
              'Position', [50, 30, 250, 30], ...
              'Callback', @resetPlots);

    function resetPlots(~, ~)
        % Close all figures except the GUI
        figs = findall(groot, 'Type', 'figure');
        gui_fig = gcf; % Assuming the current figure is the GUI
        close(setdiff(figs, gui_fig));
    end
end

%%
function runExercise31(~, ~)
    clc;
    [gamma, R, T01, p01, S_star] = defineConstants31();
    [j, x] = generateGrid31();
    S = defineAreaFunction31();
    M = solveMachDistribution31(gamma, S, S_star, x);
    [T, p] = calculateDistributions31(M, gamma, T01, p01);
    plotResults31(x, M, p);
    %%
    function [gamma, R, T01, p01, S_star] = defineConstants31()
        gamma = 1.4; % Specific heat ratio
        R = 287; % Universal gas constant [J/(kg*K)]
        T01 = 300; % Total inlet temperature [K]
        p01 = 100e3; % Total inlet pressure [Pa]
        S_star = 0.8; % Critical area for subsonic flow
    end
    %%
    function [j, x] = generateGrid31()
        j = 100;
        Ll = 0;
        Lr = 10;
        x = linspace(Ll, Lr, j);
    end
    %%
    function S = defineAreaFunction31()
        S = @(x) (x >= 0 & x <= 5) .* (1 + 1.5 * (1 - x/5).^2) + ...
                 (x > 5 & x <= 10) .* (1 + 0.5 * (1 - x/5).^2);
    end
    %%
    function [f, df] = areaMachFunction31(M, gamma, Sx, S_star)
        % Calculate the area ratio and its derivative with respect to M
        area_ratio = (1./M) .* ((2/(gamma + 1)) .* (1 + (gamma - 1)/2 .* M.^2)).^((gamma + 1)/(2*(gamma - 1)));
        f = area_ratio - Sx/S_star;
        df = -((gamma + 1)./(2.*(gamma - 1))) .* (1./M.^2) .* ((2./(gamma + 1)) .* (1 + (gamma - 1)/2 .* M.^2)).^((gamma + 1)/(2*(gamma - 1)) - 1) .* ...
             ((2./(gamma + 1)) .* (gamma - 1) .* M);
    end
    %%
    function M = solveMachDistribution31(gamma, S, S_star, x)
        M = zeros(size(x)); % Initialize Mach number array
        M(:) = 0.5; % Initial guess for Mach number (subsonic)
        options = optimoptions('fsolve', 'Display', 'off', 'TolFun', 1e-6);
        for i = 1:length(x)
            M(i) = fsolve(@(M) areaMachFunction31(M, gamma, S(x(i)), S_star), M(i), options);
        end
    end
    %%
    function [T, p] = calculateDistributions31(M, gamma, T01, p01)
        T = T01 ./ (1 + (gamma - 1)/2 .* M.^2);
        p = p01 * (1 + (gamma - 1)/2 .* M.^2).^(-gamma/(gamma - 1));
    end
    %%
    function plotResults31(x, M, p)
        figure('name', 'Exact solution for the subsonic channel flow problem');
        subplot(2, 1, 1);
        plot(x, p/1000, 'Color', 'k');
        title('Pressure');
        xlabel('x');
        ylabel('p [kPa]');
        yticks(80:2:98);
        ylim([80 98]);
    
        subplot(2, 1, 2);
        plot(x, M, 'Color', 'k');
        title('Mach Number');
        xlabel('x');
        ylabel('M');
        yticks(0.2:.05:.65);
        ylim([0.15 0.65]);
    
        % Set figure position to be centered from top to bottom of the screen
        screen_size = get(0, 'ScreenSize'); % Get the screen size
        fig_width = 400;
        fig_height = 700;
        fig_x = (screen_size(3) - fig_width) / 2; % Horizontally centered
        fig_y = (screen_size(4) - fig_height) / 2; % Vertically centered
        set(gcf, 'Position', [fig_x, fig_y, fig_width, fig_height]);
    end
end
%%
function runExercise32(~, ~)
    clc;
    [gamma, R, T01, p01, S_star, x_shock, j, x] = setupSimulation32();
    S = defineAreaFunction32();
    [M, M_post_shock] = initializeMachNumber32(j, x, gamma);
    [M, p] = solveTransonicFlow32(gamma, S, S_star, x, M, p01);
    plotResults32(x, M, p);
    %%
    function [gamma, R, T01, p01, S_star, x_shock, j, x] = setupSimulation32()
        gamma = 1.4; % Specific heat ratio
        R = 287; % Universal gas constant [J/(kg*K)]
        T01 = 300; % Total inlet temperature [K]
        p01 = 100e3; % Total inlet pressure [Pa]
        S_star = 1; % Critical area
        x_shock = 7; % Shock location
        j = 1000; % Number of grid points
        x = linspace(0, 10, j); % Grid space
    end
    %%
    function S = defineAreaFunction32()
        S = @(x) (x >= 0 & x <= 5) .* (1 + 1.5 * (1 - x/5).^2) + ...
                 (x > 5 & x <= 10) .* (1 + 0.5 * (1 - x/5).^2);
    end
    %%
    function [M, M_post_shock] = initializeMachNumber32(j, x, gamma)
        M = zeros(1, j);
        M_post_shock = NaN; 
        for i = 1:j
            if x(i) < 5
                % Use a subsonic guess before the shock
                M(i) = 0.5; 
            elseif x(i) >= 5 && x(i) < 7
                % Use a supersonic guess before the shock
                M(i) = 1.2;
            else
                % If shock has been passed, use Rankine-Hugoniot relations for post-shock Mach number
                if isnan(M_post_shock)
                    M_post_shock = calculatePostShockMach32(M(i-1), gamma);
                end
                % Use a subsonic guess after the shock
                M(i) = 0.6;
            end
        end
    end
    %%
    function [M, p] = solveTransonicFlow32(gamma, S, S_star, x, M, p01)
        % Solve for Mach number distribution and calculate pressure
        options = optimoptions('fsolve', 'Display', 'off', 'TolFun', 1e-6);
        for i = 1:length(x)
            % Iteratively solve for Mach number using fsolve
            M(i) = fsolve(@(M) areaMachRelation32(M, gamma, S(x(i)), S_star), M(i), options);
            % Calculate pressure using isentropic relations
            p(i) = p01 * (1 + 0.5 * (gamma - 1) * M(i)^2)^(-gamma/(gamma-1));
        end
    end
    %%
    function F = areaMachRelation32(M, gamma, Sx, S_star)
        % Correct implementation of Equation 3.45
        F = (Sx/S_star) - (1/M) * ((2/(gamma + 1)) * (1 + (gamma - 1)/2 * M^2))^((gamma + 1)/(2*(gamma - 1)));
    end
    %%
    function M_post_shock = calculatePostShockMach32(M_pre_shock, gamma)
        % Correct implementation of Rankine-Hugoniot relations (Equation 3.49)
        M_post_shock = sqrt((1 + (gamma - 1)/2 * M_pre_shock^2) / (gamma * M_pre_shock^2 - (gamma - 1)/2));
    end
    %%
    function plotResults32(x, M, p)
        figure;
        subplot(2, 1, 1);
        plot(x, p, 'Color', 'k');
        title('Pressure');
        xlabel('x');
        ylabel('p [Pa]');
        subplot(2, 1, 2);
        plot(x, M, 'Color', 'k');
        title('Mach Number');
        xlabel('x ');
        ylabel('M');
        ylim([.2 1.6]);
        screen_size = get(0, 'ScreenSize');
        fig_width = 400;
        fig_height = 700;
        fig_x = (screen_size(3) - fig_width) / 2;
        fig_y = (screen_size(4) - fig_height) / 2; 
        set(gcf, 'Position', [fig_x, fig_y, fig_width, fig_height]);
    end
end
%%
function runExercise33(~, ~)
    clc;
    % 1. Problem & geometry specification
    [gamma, pL, pR, rhoL, rhoR, aL, aR, t] = specifyProblem();
    [x0, x_domain] = specifyGeometry();
    % 2. Exact solution of governing equations & plotting
    [density, mach_number, pressure] = arrayfun(@(x) getState(x, t, pL, pR, rhoL, rhoR, aL, aR, gamma, x0), x_domain);
    plotResults33(x_domain, density, mach_number, pressure)
    %%
    function [gamma, pL, pR, rhoL, rhoR, aL, aR, t] = specifyProblem()
        clc;
        % Initial L & R pressures, densities, specific heat ratio, and solution time as per Exercise 3.3
        [pL, pR, rhoL, rhoR, gamma, t] = deal(1e5, 1e4, 1, 0.125, 1.4, 6.1e-3); 
        % Sound speeds in left and right sections determined from the specified pressures and densities (Equation 3.13)
        [aL, aR] = deal(sqrt(gamma * pL / rhoL), sqrt(gamma * pR / rhoR)); 
    end
    %%
    function [x0, x_domain] = specifyGeometry()
        % Length of the shock tube
        L = 10;
        % Assumed initial location of the diaphragm
        x0 = 5;
        % Number of points for discretizing the domain
        j = 1000; 
        % Spatial domain
        x_domain = linspace(0, L, j);
    end
    %%
    function [density, mach_number, pressure] = getState(x, t, pL, pR, rhoL, rhoR, aL, aR, gamma, x0)
        % Initialization
        [P, V, C, rho3, rho2, p2] = computeShockAndContactSpeeds(pL, pR, aL, aR, rhoL, rhoR, gamma);
    
        % Define region intersects based on x values
        int_L5 = x0 - aL * t; % Head of the expansion wave
        int_53 = x0 + (V * (gamma + 1) / 2 - aL) * t; % Tail of the expansion fan using correct characteristic speed
        int_32 = x0 + V * t; % Contact surface
        int_2R = x0 + C * t; % Shock wave
    
        % Determine the state based on the position x
        if x < int_L5
            % Region L
            [density, mach_number, pressure] = computeRegionL(rhoL, pL);
        elseif x >= int_L5 && x < int_53
            % Expansion Fan
            [density, mach_number, pressure] = computeExpansionFan(x, x0, aL, pL, rhoL, gamma, t);
        elseif x >= int_53 && x < int_32
            % Region 3 - Post-Contact
            [density, mach_number, pressure] = computePostContact(p2, rhoL, gamma, pL, V);
        elseif x >= int_32 && x < int_2R
            % Region 2 - Post-Shock
            [density, mach_number, pressure] = computePostShock(P, pR, rhoR, gamma, V);
        else
            % Region R
            [density, mach_number, pressure] = computeRegionR(rhoR, pR);
        end
    end
    %%
    function [P, V, C, rho3, rho2, p2] = computeShockAndContactSpeeds(pL, pR, aL, aR, rhoL, rhoR, gamma)   
        % Modify the initial guesses for pressure ratio P if necessary
        % The interval for P must bracket the root, so we choose P_min and P_max
        % to ensure that they are on opposite sides of the root.
        P_min = pR / pL; % Minimum possible value for P (when the pressure ratio is 1:1)
        P_max = pL / pR; % Maximum possible value for P (when all of the pressure from pL transfers to pR)
        P_guess = 0.5 * (P_min + P_max); % Updated guess interval
        
        % Function handle for the pressure function
        % This function is derived from the shock jump conditions and the isentropic
        % flow relations for the expansion fan.
        PFun = @(P) P_fun(P, pL, pR, aL, aR, gamma);
        dPFun = @(P) dP_fun(P, pL, pR, aL, aR, gamma);
        
        % Solve for the pressure ratio P using a nonlinear solver
        P = newtonsMethod(PFun, dPFun, P_guess, 1e-5, 100);
    
        % Calculate p2, rho2, V, and C using the obtained pressure ratio P
        % These are derived from the Rankine-Hugoniot relations and the conditions
        % across the contact discontinuity.
        alpha = (gamma + 1) / (gamma - 1); 
        p2 = P * pR; % Pressure behind the shock
        rho2 = rhoR * (1 + alpha * P) / (alpha + P); % Density behind the shock
        p3 = p2; % Pressure is constant across the contact discontinuity
        V = 2 * aL / (gamma - 1) * (1 - (p3 / pL).^((gamma - 1) / (2 * gamma))); % Velocity behind the contact surface
        rho3 = rhoL * (p3 / pL).^(1 / gamma); % Density using isentropic relation
        C = (P - 1) * aR^2 / (gamma * V); % Shock speed (Equation 3.58)
    end
    %%
    function F = P_fun(P, pL, pR, aL, aR, gamma)
        % Implicit equation for pressure P across the shock
        alpha = (gamma + 1) / (gamma - 1);
        term1 = sqrt(2 / (gamma * (gamma - 1))) * (P - 1) / sqrt(1 + alpha * P);
        term2 = (2 / (gamma - 1)) * (aL / aR);
        term3 = (1 - (pR * P / pL).^((gamma - 1) / (2 * gamma)));
    
        F = term1 - term2 * term3;
    end
    %%
    function F = dP_fun(P, pL, pR, aL, aR, gamma)
        alpha = (gamma + 1) / (gamma - 1);
    
        % Derivative of term1 with respect to P
        dterm1 = sqrt(2 / (gamma * (gamma - 1))) * (1 ./ sqrt(1 + alpha * P) - (P - 1) * alpha ./ (2 * (1 + alpha * P).^(3/2)));
    
        % Derivative of term3 with respect to P
        dterm3 = -pR / pL * ((gamma - 1) / (2 * gamma)) * (pR * P / pL).^((gamma - 1) / (2 * gamma) - 1);
    
        % The derivative of F with respect to P
        F = dterm1 - (2 / (gamma - 1)) * (aL / aR) * dterm3;
    end
    %%
    function P = newtonsMethod(fun, dPFun, initialGuess, tol, maxIter)
        P = initialGuess;
        for iter = 1:maxIter
            f_val = fun(P);
            f_prime = dPFun(P);  % Make sure this returns a scalar
    
            % Check for zero derivative (to avoid division by zero)
            if abs(f_prime) < 1e-12
                error('Newton''s method failed: derivative too small.');
            end
    
            % Update P using Newton's method
            P_new = P - f_val / f_prime;  % This should be a scalar update
    
            % Check convergence
            if abs(P_new - P) < tol
                P = P_new;
                break;
            end
    
            P = P_new;
        end
    
        if iter == maxIter
            error('Newton''s method did not converge within the maximum number of iterations');
        end
    end
    %%
    function [density, mach_number, pressure] = computeRegionL(rhoL, pL)
            density = rhoL;
            mach_number = 0;
            pressure = pL;
    end
    %%
    function [density, mach_number, pressure] = computeExpansionFan(x, x0, aL, pL, rhoL, gamma, t)
        % Compute the local speed of sound within the expansion fan
        u5 = (2 / (gamma + 1)) * ((x - x0) / t + aL);
        a5 = aL - ((gamma - 1) / 2) * u5;
    
        % Compute the pressure within the expansion fan
        p5 = pL * (a5 / aL)^(2 * gamma / (gamma - 1));
    
        % Compute the density within the expansion fan
        rho5 = rhoL * (p5 / pL)^(1 / gamma);
    
        % Compute the Mach number within the expansion fan
        M5 = u5 / a5;
    
        % Assign outputs to the function
        density = rho5;
        mach_number = M5;
        pressure = p5;
    end
    %%
    function [density, mach_number, pressure] = computePostContact(p2, rhoL, gamma, pL, V)
        % The pressure behind the contact surface is the same as the pressure p2
        % from the post-shock region, and since the flow is isentropic, the density
        % changes according to isentropic relations.
        pressure = p2;
        
        % Calculate the density using isentropic relations, since the entropy to
        % the left of the contact surface is equal to that of the original
        % quiescent left state.
        density = rhoL * (pressure / pL)^(1 / gamma);
        
        % The velocity V is the same across the contact discontinuity and is
        % equal to the speed of the contact surface.
        mach_number = V / (sqrt(gamma * pressure / density)); % Mach number using the speed of sound after the contact surface
    end
    %%
    function [density, mach_number, pressure] = computePostShock(P, pR, rhoR, gamma, V)
        % This function computes the flow properties in region 2, which is 
        % immediately behind the shock wave and is governed by the Rankine-Hugoniot 
        % relations due to the shock.
        
        % Pressure behind the shock is P times the right pressure (pR).
        pressure = P * pR;
        
        % Density behind the shock (rho2) calculated using the shock pressure ratio (P).
        alpha = (gamma + 1) / (gamma - 1);
        density = rhoR * (alpha * P + 1) / (alpha + P);
        
        % Mach number behind the shock is the velocity divided by the speed of sound in region 2.
        mach_number = V / sqrt(gamma * pressure / density);
    end
    %%
    function [density, mach_number, pressure] = computeRegionR(rhoR, pR)
            density = rhoR;
            mach_number = 0;
            pressure = pR;
    end
    %%
    function plotResults33(x, rho, M, P)
        % This function plots the density and Mach number profiles
        % The figure setup is based on the layout of Fig. 3.3 from the textbook
        
        figure('Name', 'Shock Tube Problem Results');
    
        subplot(2, 1, 1);
        plot(x, rho, 'Color', 'k');
        title('Density (in Kg/m^3)'); % Title based on Fig. 3.3a in the textbook
        xlabel('x'); % x-axis label as per standard convention
        xlim([0 10]); % x-axis limits as per the domain specified in the textbook's example
        ylabel('\rho', 'Interpreter', 'tex'); % y-axis label using LaTeX formatting as in the textbook
        ylim([0 1.1]); % y-axis limits based on expected range of density values
        yticks(0:.2:1); % y-axis ticks setting for density plot
    
        subplot(2, 1, 2);
        plot(x, M, 'Color', 'k');
        title('Mach Number'); % Title based on Fig. 3.3b in the textbook
        xlabel('x '); % x-axis label as per standard convention
        xlim([0 10]); % x-axis limits as per the domain specified in the textbook's example
        ylabel('M'); % y-axis label for Mach number
        ylim([0 1]); % y-axis limits based on expected range of Mach number values
        yticks(0:.1:1); % y-axis ticks setting for Mach number plot
        
        % subplot(3, 1, 3);
        % plot(x, P, 'Color', 'k');
        % title('Pressure'); % Title based on Fig. 3.3b in the textbook
        % xlabel('x '); % x-axis label as per standard convention
        % xlim([0 10]); % x-axis limits as per the domain specified in the textbook's example
        % ylabel('P'); % y-axis label for Mach number
        % ylim([1e4 1.1e5]); % y-axis limits based on expected range of Mach number values
        
        % Adjust figure window size and position on screen
        screen_size = get(0, 'ScreenSize');
        fig_width = 400;
        fig_height = 700;
        fig_x = (screen_size(3) - fig_width) / 2;
        fig_y = (screen_size(4) - fig_height) / 2; 
        set(gcf, 'Position', [fig_x, fig_y, fig_width, fig_height]);
    end
end
    